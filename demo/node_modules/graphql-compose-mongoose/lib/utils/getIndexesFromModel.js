"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIndexedFieldNamesForGraphQL = exports.extendByReversedIndexes = exports.getUniqueIndexes = exports.getIndexesFromModel = void 0;
function isSpecificIndex(idx) {
    let hasSpecialIndex = false;
    Object.keys(idx).forEach((k) => {
        if (typeof idx[k] !== 'number' && typeof idx[k] !== 'boolean') {
            hasSpecialIndex = true;
        }
    });
    return hasSpecialIndex;
}
function getIndexesFromModel(mongooseModel, opts = {}) {
    const extractCompound = opts.extractCompound === undefined ? true : Boolean(opts.extractCompound);
    const skipSpecificIndexes = opts.skipSpecificIndexes === undefined ? true : Boolean(opts.skipSpecificIndexes);
    const indexedFields = [];
    if (mongooseModel.schema.paths._id) {
        indexedFields.push({ _id: 1 });
    }
    Object.keys(mongooseModel.schema.paths).forEach((name) => {
        if (mongooseModel.schema.paths[name]._index) {
            indexedFields.push({ [name]: 1 });
        }
    });
    if (Array.isArray(mongooseModel.schema._indexes)) {
        mongooseModel.schema._indexes.forEach((idxData) => {
            const partialIndexes = {};
            const idxFields = idxData[0];
            if (!skipSpecificIndexes || !isSpecificIndex(idxFields)) {
                if (!extractCompound) {
                    indexedFields.push(idxFields);
                }
                else {
                    Object.keys(idxFields).forEach((fieldName) => {
                        partialIndexes[fieldName] = idxFields[fieldName];
                        indexedFields.push(Object.assign({}, partialIndexes));
                    });
                }
            }
        });
    }
    const tmp = [];
    const result = indexedFields.filter((val) => {
        const asString = JSON.stringify(val);
        if (tmp.indexOf(asString) > -1)
            return false;
        tmp.push(asString);
        return true;
    });
    return result;
}
exports.getIndexesFromModel = getIndexesFromModel;
function getUniqueIndexes(mongooseModel) {
    const indexedFields = [];
    if (mongooseModel.schema.paths._id) {
        indexedFields.push({ _id: 1 });
    }
    Object.keys(mongooseModel.schema.paths).forEach((name) => {
        var _a, _b;
        if ((_b = (_a = mongooseModel.schema.paths[name]) === null || _a === void 0 ? void 0 : _a._index) === null || _b === void 0 ? void 0 : _b.unique) {
            indexedFields.push({ [name]: 1 });
        }
    });
    if (Array.isArray(mongooseModel.schema._indexes)) {
        mongooseModel.schema._indexes.forEach((idxData) => {
            const idxFields = idxData[0];
            const idxCfg = idxData[1];
            if (idxCfg.unique && !isSpecificIndex(idxFields)) {
                indexedFields.push(idxFields);
            }
        });
    }
    return indexedFields;
}
exports.getUniqueIndexes = getUniqueIndexes;
function extendByReversedIndexes(indexes, opts = {}) {
    const reversedFirst = opts.reversedFirst === undefined ? false : Boolean(opts.reversedFirst);
    const result = [];
    indexes.forEach((indexObj) => {
        let hasSpecificIndex = false;
        const reversedIndexObj = Object.assign({}, indexObj);
        Object.keys(reversedIndexObj).forEach((f) => {
            if (reversedIndexObj[f] === 1)
                reversedIndexObj[f] = -1;
            else if (reversedIndexObj[f] === -1)
                reversedIndexObj[f] = 1;
            else
                hasSpecificIndex = true;
        });
        if (reversedFirst) {
            if (!hasSpecificIndex) {
                result.push(reversedIndexObj);
            }
            result.push(indexObj);
        }
        else {
            result.push(indexObj);
            if (!hasSpecificIndex) {
                result.push(reversedIndexObj);
            }
        }
    });
    return result;
}
exports.extendByReversedIndexes = extendByReversedIndexes;
function getIndexedFieldNamesForGraphQL(model) {
    const indexes = getIndexesFromModel(model);
    const fieldNames = [];
    indexes.forEach((indexData) => {
        const keys = Object.keys(indexData);
        const clearedName = keys[0].replace(/[^_a-zA-Z0-9]/i, '__');
        fieldNames.push(clearedName);
    });
    const uniqueNames = [];
    const result = fieldNames.filter((val) => {
        if (uniqueNames.indexOf(val) > -1)
            return false;
        uniqueNames.push(val);
        return true;
    });
    return result;
}
exports.getIndexedFieldNamesForGraphQL = getIndexedFieldNamesForGraphQL;
//# sourceMappingURL=getIndexesFromModel.js.map