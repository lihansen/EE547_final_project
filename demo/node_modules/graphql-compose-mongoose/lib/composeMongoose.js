"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareInputFields = exports.createInputType = exports.prepareFields = exports.composeMongoose = void 0;
const graphql_compose_1 = require("graphql-compose");
const fieldsConverter_1 = require("./fieldsConverter");
const resolvers_1 = require("./resolvers");
const MongoID_1 = __importDefault(require("./types/MongoID"));
function composeMongoose(model, opts = {}) {
    const m = model;
    const name = (opts && opts.name) || m.modelName;
    const sc = opts.schemaComposer || graphql_compose_1.schemaComposer;
    sc.add(MongoID_1.default);
    if (sc.has(name)) {
        throw new Error(`You try to generate GraphQL Type with name ${name} from mongoose model but this type already exists in SchemaComposer. Please choose another type name "composeWithMongoose(model, { name: 'NewTypeName' })", or reuse existed type "schemaComposer.getOTC('TypeName')", or remove type from SchemaComposer before calling composeWithMongoose method "schemaComposer.delete('TypeName')".`);
    }
    if (sc.has(m.schema)) {
        sc.delete(m.schema);
    }
    const tc = (0, fieldsConverter_1.convertModelToGraphQL)(m, name, sc);
    if (opts.description) {
        tc.setDescription(opts.description);
    }
    prepareFields(tc, opts);
    createInputType(tc, opts.inputType);
    if (opts.defaultsAsNonNull) {
        makeFieldsNonNullWithDefaultValues(tc);
    }
    tc.makeFieldNonNull('_id');
    const mongooseResolvers = {};
    Object.keys(resolvers_1.resolverFactory).forEach((name) => {
        mongooseResolvers[name] = resolvers_1.resolverFactory[name].bind(undefined, model, tc);
    });
    tc.mongooseResolvers = mongooseResolvers;
    return tc;
}
exports.composeMongoose = composeMongoose;
function makeFieldsNonNullWithDefaultValues(tc, alreadyWorked = new Set()) {
    if (alreadyWorked.has(tc))
        return;
    alreadyWorked.add(tc);
    let hasFieldsWithDefaultValues = false;
    tc.getFieldNames().forEach((fieldName) => {
        var _a, _b;
        const fc = tc.getField(fieldName);
        if (fc.type instanceof graphql_compose_1.ObjectTypeComposer) {
            if ((_a = fc.extensions) === null || _a === void 0 ? void 0 : _a.isSingleNestedMongooseSchema) {
                return;
            }
            makeFieldsNonNullWithDefaultValues(fc.type);
            if (fc.type.getExtension('hasFieldsWithDefaultValue')) {
                tc.makeFieldNonNull(fieldName);
            }
        }
        const defaultValue = (_b = fc === null || fc === void 0 ? void 0 : fc.extensions) === null || _b === void 0 ? void 0 : _b.defaultValue;
        if (defaultValue !== null && defaultValue !== undefined) {
            hasFieldsWithDefaultValues = true;
            tc.makeFieldNonNull(fieldName);
        }
    });
    if (hasFieldsWithDefaultValues) {
        tc.setExtension('hasFieldsWithDefaultValue', true);
    }
}
function prepareFields(tc, opts = {}) {
    var _a, _b;
    const onlyFields = (opts === null || opts === void 0 ? void 0 : opts.onlyFields) || ((_a = opts === null || opts === void 0 ? void 0 : opts.fields) === null || _a === void 0 ? void 0 : _a.only);
    if (onlyFields) {
        tc.removeOtherFields(onlyFields);
    }
    const removeFields = (opts === null || opts === void 0 ? void 0 : opts.removeFields) || ((_b = opts === null || opts === void 0 ? void 0 : opts.fields) === null || _b === void 0 ? void 0 : _b.remove);
    if (removeFields) {
        tc.removeField(removeFields);
    }
}
exports.prepareFields = prepareFields;
function createInputType(tc, inputTypeOpts = {}) {
    const inputTypeComposer = tc.getInputTypeComposer();
    if (inputTypeOpts.name) {
        inputTypeComposer.setTypeName(inputTypeOpts.name);
    }
    if (inputTypeOpts.description) {
        inputTypeComposer.setDescription(inputTypeOpts.description);
    }
    prepareInputFields(inputTypeComposer, inputTypeOpts);
}
exports.createInputType = createInputType;
function prepareInputFields(inputTypeComposer, inputTypeOpts = {}) {
    var _a, _b, _c;
    const onlyFields = (inputTypeOpts === null || inputTypeOpts === void 0 ? void 0 : inputTypeOpts.onlyFields) || ((_a = inputTypeOpts === null || inputTypeOpts === void 0 ? void 0 : inputTypeOpts.fields) === null || _a === void 0 ? void 0 : _a.only);
    if (onlyFields) {
        inputTypeComposer.removeOtherFields(onlyFields);
    }
    const removeFields = (inputTypeOpts === null || inputTypeOpts === void 0 ? void 0 : inputTypeOpts.removeFields) || ((_b = inputTypeOpts === null || inputTypeOpts === void 0 ? void 0 : inputTypeOpts.fields) === null || _b === void 0 ? void 0 : _b.remove);
    if (removeFields) {
        inputTypeComposer.removeField(removeFields);
    }
    const requiredFields = (inputTypeOpts === null || inputTypeOpts === void 0 ? void 0 : inputTypeOpts.requiredFields) || ((_c = inputTypeOpts === null || inputTypeOpts === void 0 ? void 0 : inputTypeOpts.fields) === null || _c === void 0 ? void 0 : _c.required);
    if (requiredFields) {
        inputTypeComposer.makeFieldNonNull(requiredFields);
    }
}
exports.prepareInputFields = prepareInputFields;
//# sourceMappingURL=composeMongoose.js.map