"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareBaseResolvers = void 0;
const resolvers_1 = require("../resolvers");
function setDKeyEnumOnITCArgs(resolver, baseTC) {
    if (resolver) {
        const argNames = resolver.getArgNames();
        for (const argName of argNames) {
            if (argName === 'filter' || argName === 'record' || argName === 'records') {
                const filterArgTC = resolver.getArgITC(argName);
                if (filterArgTC) {
                    filterArgTC.extendField(baseTC.getDKey(), {
                        type: baseTC.getDKeyETC(),
                    });
                }
            }
        }
    }
}
function prepareBaseResolvers(baseTC) {
    Object.keys(resolvers_1.resolverFactory).forEach((resolverName) => {
        if (baseTC.hasResolver(resolverName)) {
            const resolver = baseTC.getResolver(resolverName);
            switch (resolverName) {
                case 'findMany':
                case 'findByIds':
                    resolver.setType(baseTC.getDInterface().List);
                    resolver.projection[baseTC.getDKey()] = 1;
                    break;
                case 'findById':
                case 'findOne':
                    resolver.setType(baseTC.getDInterface());
                    resolver.projection[baseTC.getDKey()] = 1;
                    break;
                case 'createOne':
                case 'updateOne':
                case 'updateById':
                case 'removeOne':
                case 'removeById':
                    resolver.getOTC().extendField('record', {
                        type: baseTC.getDInterface(),
                        projection: {
                            [baseTC.getDKey()]: 1,
                        },
                    });
                    break;
                case 'createMany':
                    resolver.getOTC().extendField('records', {
                        type: baseTC.getDInterface().List.NonNull,
                        projection: {
                            [baseTC.getDKey()]: 1,
                        },
                    });
                    break;
                case 'pagination':
                    resolver.getOTC().extendField('items', {
                        type: baseTC.getDInterface().List,
                        projection: {
                            [baseTC.getDKey()]: 1,
                        },
                    });
                    break;
                case 'connection':
                    const edgesTC = resolver
                        .getOTC()
                        .getFieldOTC('edges')
                        .clone(`${baseTC.getTypeName()}Edge`);
                    edgesTC.extendField('node', {
                        type: baseTC.getDInterface().NonNull,
                        projection: {
                            [baseTC.getDKey()]: 1,
                        },
                    });
                    resolver.getOTC().setField('edges', edgesTC.NonNull.List.NonNull);
                    break;
                default:
            }
            setDKeyEnumOnITCArgs(resolver, baseTC);
            if (resolverName === 'createOne' || resolverName === 'createMany') {
                const fieldName = resolverName === 'createMany' ? 'records' : 'record';
                resolver.getArgITC(fieldName).extendField(baseTC.getDKey(), {
                    type: baseTC.getDKeyETC().NonNull,
                });
            }
        }
    });
}
exports.prepareBaseResolvers = prepareBaseResolvers;
//# sourceMappingURL=prepareBaseResolvers.js.map