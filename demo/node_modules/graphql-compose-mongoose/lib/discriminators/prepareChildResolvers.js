"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareChildResolvers = void 0;
const resolvers_1 = require("../resolvers");
function setQueryDKey(resolver, childTC, DKey, fromField) {
    if (resolver) {
        resolver.wrapResolve((next) => (resolve) => {
            const DName = childTC.getTypeName();
            resolve.args = resolve.args ? resolve.args : {};
            resolve.projection = resolve.projection ? resolve.projection : {};
            if (fromField === 'records') {
                resolve.args[fromField] = resolve.args[fromField] || [];
                for (const record of resolve.args[fromField]) {
                    record[DKey] = DName;
                }
            }
            else if (fromField) {
                resolve.args[fromField] = resolve.args[fromField] ? resolve.args[fromField] : {};
                resolve.args[fromField][DKey] = DName;
            }
            else {
                resolve.args[DKey] = DName;
            }
            resolve.projection[DKey] = 1;
            return next(resolve);
        });
    }
}
function hideDKey(resolver, childTC, DKey, fromField) {
    if (Array.isArray(fromField)) {
        for (const field of fromField) {
            hideDKey(resolver, childTC, DKey, field);
        }
    }
    else if (fromField && resolver.hasArg(fromField)) {
        const fieldTC = resolver.getArgITC(fromField);
        if (fieldTC) {
            fieldTC.removeField(DKey);
        }
    }
    else {
        resolver.removeArg(DKey);
    }
}
function copyResolverArgTypes(resolver, baseDTC, fromArg) {
    if (resolver && baseDTC.hasInputTypeComposer()) {
        if (Array.isArray(fromArg)) {
            for (const field of fromArg) {
                copyResolverArgTypes(resolver, baseDTC, field);
            }
        }
        else if (fromArg && resolver.hasArg(fromArg)) {
            if (baseDTC.hasResolver(resolver.name) &&
                baseDTC.getResolver(resolver.name).hasArg(fromArg)) {
                const childResolverArgTC = resolver.getArgITC(fromArg);
                const baseResolverArgTC = baseDTC.getResolver(resolver.name).getArgITC(fromArg);
                const baseResolverArgTCFields = baseResolverArgTC.getFieldNames();
                for (const baseArgField of baseResolverArgTCFields) {
                    if (childResolverArgTC.hasField(baseArgField) && baseArgField !== '_id') {
                        childResolverArgTC.extendField(baseArgField, {
                            type: baseResolverArgTC.getField(baseArgField).type,
                        });
                    }
                }
            }
        }
    }
}
function reorderFieldsRecordFilter(resolver, baseDTC, order, fromField) {
    if (order) {
        if (Array.isArray(fromField)) {
            for (const field of fromField) {
                reorderFieldsRecordFilter(resolver, baseDTC, order, field);
            }
        }
        else if (fromField && resolver.hasArg(fromField)) {
            const argTC = resolver.getArgITC(fromField);
            if (Array.isArray(order)) {
                argTC.reorderFields(order);
            }
            else {
                const newOrder = [];
                if (baseDTC.hasInputTypeComposer()) {
                    newOrder.push(...baseDTC.getInputTypeComposer().getFieldNames());
                    newOrder.filter((value) => value === '_id' || value === baseDTC.getDKey());
                    newOrder.unshift('_id', baseDTC.getDKey());
                }
                argTC.reorderFields(newOrder);
            }
        }
    }
}
function prepareChildResolvers(baseDTC, childTC, opts) {
    Object.keys(resolvers_1.resolverFactory).forEach((resolverName) => {
        if (childTC.hasResolver(resolverName)) {
            const resolver = childTC.getResolver(resolverName);
            switch (resolverName) {
                case 'createOne':
                    setQueryDKey(resolver, childTC, baseDTC.getDKey(), 'record');
                    hideDKey(resolver, childTC, baseDTC.getDKey(), 'record');
                    break;
                case 'createMany':
                    setQueryDKey(resolver, childTC, baseDTC.getDKey(), 'records');
                    hideDKey(resolver, childTC, baseDTC.getDKey(), 'records');
                    break;
                case 'updateById':
                    hideDKey(resolver, childTC, baseDTC.getDKey(), 'record');
                    break;
                case 'updateOne':
                case 'updateMany':
                    setQueryDKey(resolver, childTC, baseDTC.getDKey(), 'filter');
                    hideDKey(resolver, childTC, baseDTC.getDKey(), ['record', 'filter']);
                    break;
                case 'findOne':
                case 'findMany':
                case 'findOneLean':
                case 'findManyLean':
                case 'removeOne':
                case 'removeMany':
                case 'count':
                case 'pagination':
                case 'connection':
                    setQueryDKey(resolver, childTC, baseDTC.getDKey(), 'filter');
                    hideDKey(resolver, childTC, baseDTC.getDKey(), 'filter');
                    break;
                default:
            }
            copyResolverArgTypes(resolver, baseDTC, ['filter', 'record', 'records']);
            reorderFieldsRecordFilter(resolver, baseDTC, opts.reorderFields, [
                'filter',
                'record',
                'records',
            ]);
        }
    });
}
exports.prepareChildResolvers = prepareChildResolvers;
//# sourceMappingURL=prepareChildResolvers.js.map