"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.composeChildTC = void 0;
const prepareChildResolvers_1 = require("./prepareChildResolvers");
const reorderFields_1 = require("./utils/reorderFields");
function copyBaseTcRelationsToChildTc(baseDTC, childTC) {
    const relations = baseDTC.getRelations();
    const childRelations = childTC.getRelations();
    Object.keys(relations).forEach((name) => {
        if (childRelations[name]) {
            return;
        }
        childTC.addRelation(name, relations[name]);
    });
    return childTC;
}
function copyBaseTCFieldsToChildTC(baseDTC, childTC) {
    const baseFields = baseDTC.getFieldNames();
    const childFields = childTC.getFieldNames();
    for (const field of baseFields) {
        const isFieldExists = childFields.find((fld) => fld === field);
        if (isFieldExists) {
            childTC.extendField(field, {
                type: baseDTC.getField(field).type,
            });
        }
        else {
            childTC.setField(field, baseDTC.getField(field));
        }
    }
    return childTC;
}
function composeChildTC(baseDTC, childTC, opts) {
    let composedChildTC = copyBaseTcRelationsToChildTc(baseDTC, childTC);
    composedChildTC = copyBaseTCFieldsToChildTC(baseDTC, composedChildTC);
    composedChildTC.addInterface(baseDTC.getDInterface());
    (0, prepareChildResolvers_1.prepareChildResolvers)(baseDTC, composedChildTC, opts);
    (0, reorderFields_1.reorderFields)(composedChildTC, opts.reorderFields, baseDTC.getDKey(), baseDTC.getFieldNames());
    return composedChildTC;
}
exports.composeChildTC = composeChildTC;
//# sourceMappingURL=composeChildTC.js.map