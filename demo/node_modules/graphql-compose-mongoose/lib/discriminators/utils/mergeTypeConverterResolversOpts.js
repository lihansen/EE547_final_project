"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeTypeConverterResolverOpts = exports.mergeMapTypeFields = exports.mergeArraysTypeFields = exports.mergeFilterOperatorsOptsMap = exports.mergePrimitiveTypeFields = void 0;
const helpers_1 = require("../../resolvers/helpers");
const mergeCustomizationOptions_1 = require("./mergeCustomizationOptions");
function mergePrimitiveTypeFields(baseField, childField, argOptsTypes) {
    if (Array.isArray(argOptsTypes)) {
        if (argOptsTypes.find((v) => v === 'boolean' || v === 'number')) {
            return mergePrimitiveTypeFields(baseField, childField, 'boolean');
        }
    }
    if (argOptsTypes === 'boolean' || argOptsTypes === 'number') {
        if (childField === undefined) {
            return baseField;
        }
        else {
            return childField;
        }
    }
    return childField;
}
exports.mergePrimitiveTypeFields = mergePrimitiveTypeFields;
function mergeFilterOperatorsOptsMap(baseFilterOperatorField, childFilterOperatorField) {
    const baseOptsKeys = Object.keys(baseFilterOperatorField);
    const baseOptsTypes = {};
    for (const key of baseOptsKeys) {
        baseOptsTypes[key] = 'string[]';
    }
    childFilterOperatorField = mergeMapTypeFields(baseFilterOperatorField, childFilterOperatorField, baseOptsTypes);
    return childFilterOperatorField;
}
exports.mergeFilterOperatorsOptsMap = mergeFilterOperatorsOptsMap;
function mergeArraysTypeFields(baseField, childField, argOptsType) {
    let merged = childField !== undefined ? childField : {};
    if (Array.isArray(argOptsType)) {
        for (const argType of argOptsType) {
            if (argType === 'FilterOperatorsOptsMap') {
                merged = mergeFilterOperatorsOptsMap(baseField, merged);
                continue;
            }
            merged = mergePrimitiveTypeFields(baseField, childField, argType);
            merged = (0, mergeCustomizationOptions_1.mergeStringAndStringArraysFields)(baseField, merged, argType);
        }
    }
    return merged;
}
exports.mergeArraysTypeFields = mergeArraysTypeFields;
function mergeMapTypeFields(baseField, childField, argOptsTypes) {
    const merged = childField === undefined ? {} : childField;
    if (argOptsTypes !== null && typeof argOptsTypes === 'object') {
        for (const argOptType in argOptsTypes) {
            if (argOptsTypes.hasOwnProperty(argOptType)) {
                if (baseField[argOptType] === undefined) {
                    continue;
                }
                if (childField === undefined) {
                    childField = {};
                }
                if (argOptType === 'FilterOperatorsOptsMap') {
                    merged[argOptType] = mergeFilterOperatorsOptsMap(baseField[argOptType], merged[argOptType]);
                    continue;
                }
                merged[argOptType] = mergePrimitiveTypeFields(baseField[argOptType], childField[argOptType], argOptsTypes[argOptType]);
                merged[argOptType] = (0, mergeCustomizationOptions_1.mergeStringAndStringArraysFields)(baseField[argOptType], merged[argOptType], argOptsTypes[argOptType]);
                merged[argOptType] = mergeArraysTypeFields(baseField[argOptType], merged[argOptType], argOptsTypes[argOptType]);
            }
        }
    }
    return merged;
}
exports.mergeMapTypeFields = mergeMapTypeFields;
function mergeTypeConverterResolverOpts(baseTypeConverterResolverOpts, childTypeConverterResolverOpts) {
    if (!baseTypeConverterResolverOpts) {
        return childTypeConverterResolverOpts;
    }
    if (!childTypeConverterResolverOpts) {
        return baseTypeConverterResolverOpts;
    }
    const mergedTypeConverterResolverOpts = JSON.parse(JSON.stringify(childTypeConverterResolverOpts)) || {};
    for (const baseResolverOpt in baseTypeConverterResolverOpts) {
        if (baseTypeConverterResolverOpts.hasOwnProperty(baseResolverOpt)) {
            const baseResolverArgs = baseTypeConverterResolverOpts[baseResolverOpt];
            let childResolverArgs = childTypeConverterResolverOpts[baseResolverOpt];
            if (baseResolverArgs === undefined) {
                continue;
            }
            if (baseResolverArgs === false && childResolverArgs === undefined) {
                mergedTypeConverterResolverOpts[baseResolverOpt] = false;
                continue;
            }
            if (childResolverArgs === undefined) {
                childResolverArgs = {};
            }
            const mergedResolverArgs = mergedTypeConverterResolverOpts[baseResolverOpt] || {};
            for (const baseResolverArg in baseResolverArgs) {
                if (baseResolverArgs.hasOwnProperty(baseResolverArg)) {
                    const argOptsType = helpers_1.MergeAbleHelperArgsOpts[baseResolverArg];
                    if (baseResolverArgs[baseResolverArg] === undefined) {
                        continue;
                    }
                    mergedResolverArgs[baseResolverArg] = mergePrimitiveTypeFields(baseResolverArgs[baseResolverArg], childResolverArgs[baseResolverArg], argOptsType);
                    mergedResolverArgs[baseResolverArg] = mergeMapTypeFields(baseResolverArgs[baseResolverArg], mergedResolverArgs[baseResolverArg], argOptsType);
                    mergedResolverArgs[baseResolverArg] = mergeArraysTypeFields(baseResolverArgs[baseResolverArg], mergedResolverArgs[baseResolverArg], argOptsType);
                }
            }
            mergedTypeConverterResolverOpts[baseResolverOpt] = mergedResolverArgs;
        }
    }
    return mergedTypeConverterResolverOpts;
}
exports.mergeTypeConverterResolverOpts = mergeTypeConverterResolverOpts;
//# sourceMappingURL=mergeTypeConverterResolversOpts.js.map