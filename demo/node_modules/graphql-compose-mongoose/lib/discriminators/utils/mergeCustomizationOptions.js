"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeCustomizationOptions = exports.mergeFieldMaps = exports.mergeStringAndStringArraysFields = void 0;
const mergeTypeConverterResolversOpts_1 = require("./mergeTypeConverterResolversOpts");
function mergeStringAndStringArraysFields(baseField, childField, argOptsTypes) {
    if (Array.isArray(argOptsTypes)) {
        if (argOptsTypes.find((v) => v === 'string' || v === 'string[]')) {
            return mergeStringAndStringArraysFields(baseField, childField, 'string');
        }
    }
    let merged = childField;
    if (argOptsTypes === 'string' || argOptsTypes === 'string[]') {
        if (!baseField) {
            if (childField) {
                return Array.isArray(childField) ? childField : [childField];
            }
            return undefined;
        }
        if (!childField) {
            if (baseField) {
                return Array.isArray(baseField) ? baseField : [baseField];
            }
            return undefined;
        }
        merged = Array.of(...(Array.isArray(baseField) ? baseField : [baseField]), ...(Array.isArray(childField) ? childField : [childField]));
        let length = merged.length;
        for (let i = 0; i <= length; i++) {
            for (let j = i + 1; j < length; j++) {
                if (merged[i] === merged[j]) {
                    merged.splice(j, 1);
                    length--;
                }
            }
        }
    }
    return merged;
}
exports.mergeStringAndStringArraysFields = mergeStringAndStringArraysFields;
function mergeFieldMaps(baseFieldMap, childFieldMap) {
    if (!baseFieldMap) {
        return childFieldMap;
    }
    const mergedFieldMap = childFieldMap || {};
    for (const key in baseFieldMap) {
        if (baseFieldMap.hasOwnProperty(key)) {
            mergedFieldMap[key] = mergeStringAndStringArraysFields(baseFieldMap[key], mergedFieldMap[key], 'string');
        }
    }
    return mergedFieldMap;
}
exports.mergeFieldMaps = mergeFieldMaps;
function mergeCustomizationOptions(baseCOptions, childCOptions) {
    if (!baseCOptions) {
        return childCOptions;
    }
    const mergedOptions = childCOptions || {};
    if (baseCOptions.schemaComposer !== mergedOptions.schemaComposer &&
        mergedOptions.schemaComposer) {
        throw new Error('[Discriminators] ChildModels should have same schemaComposer as its BaseModel');
    }
    mergedOptions.schemaComposer = baseCOptions.schemaComposer;
    if (baseCOptions.fields) {
        mergedOptions.fields = mergeFieldMaps(baseCOptions.fields, mergedOptions.fields);
    }
    if (baseCOptions.inputType && baseCOptions.inputType.fields) {
        if (mergedOptions.inputType) {
            mergedOptions.inputType.fields = mergeFieldMaps(baseCOptions.inputType.fields, mergedOptions.inputType.fields);
        }
        else {
            mergedOptions.inputType = {
                fields: mergeFieldMaps(baseCOptions.inputType.fields, undefined),
            };
        }
    }
    mergedOptions.resolvers = (0, mergeTypeConverterResolversOpts_1.mergeTypeConverterResolverOpts)(baseCOptions.resolvers, mergedOptions.resolvers);
    return mergedOptions;
}
exports.mergeCustomizationOptions = mergeCustomizationOptions;
//# sourceMappingURL=mergeCustomizationOptions.js.map