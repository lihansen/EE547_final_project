"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareCursorQuery = exports.connection = void 0;
const graphql_compose_connection_1 = require("graphql-compose-connection");
const count_1 = require("./count");
const findMany_1 = require("./findMany");
const getIndexesFromModel_1 = require("../utils/getIndexesFromModel");
function connection(model, tc, opts) {
    const uniqueIndexes = (0, getIndexesFromModel_1.extendByReversedIndexes)((0, getIndexesFromModel_1.getUniqueIndexes)(model), {
        reversedFirst: true,
    });
    const sortConfigs = {};
    uniqueIndexes.forEach((indexData) => {
        const keys = Object.keys(indexData);
        let name = keys
            .join('__')
            .toUpperCase()
            .replace(/[^_a-zA-Z0-9]/i, '__');
        if (indexData[keys[0]] === 1) {
            name = `${name}_ASC`;
        }
        else if (indexData[keys[0]] === -1) {
            name = `${name}_DESC`;
        }
        sortConfigs[name] = {
            value: indexData,
            cursorFields: keys,
            beforeCursorQuery: (rawQuery, cursorData) => {
                prepareCursorQuery(rawQuery, cursorData, keys, indexData, '$lt', '$gt');
            },
            afterCursorQuery: (rawQuery, cursorData) => {
                prepareCursorQuery(rawQuery, cursorData, keys, indexData, '$gt', '$lt');
            },
        };
    });
    const _a = opts || {}, { findManyOpts, countOpts, findManyResolver, countResolver } = _a, restOpts = __rest(_a, ["findManyOpts", "countOpts", "findManyResolver", "countResolver"]);
    return (0, graphql_compose_connection_1.prepareConnectionResolver)(tc, Object.assign({ findManyResolver: findManyResolver || (0, findMany_1.findMany)(model, tc, findManyOpts), countResolver: countResolver || (0, count_1.count)(model, tc, countOpts), sort: sortConfigs }, restOpts));
}
exports.connection = connection;
function prepareCursorQuery(rawQuery, cursorData, indexKeys, indexData, nextOper, prevOper) {
    if (indexKeys.length === 1) {
        const k = indexKeys[0];
        if (!rawQuery[k])
            rawQuery[k] = {};
        if (indexData[k] === 1) {
            rawQuery[k][nextOper] = cursorData[k];
        }
        else {
            rawQuery[k][prevOper] = cursorData[k];
        }
    }
    else {
        const orCriteries = [];
        for (let i = indexKeys.length - 1; i >= 0; i--) {
            const criteria = {};
            indexKeys.forEach((k, ii) => {
                if (ii < i) {
                    criteria[k] = cursorData[k];
                }
                else if (ii === i) {
                    if (indexData[k] === 1) {
                        criteria[k] = { [nextOper]: cursorData[k] };
                    }
                    else {
                        criteria[k] = { [prevOper]: cursorData[k] };
                    }
                }
            });
            orCriteries.push(criteria);
        }
        rawQuery.$or = orCriteries;
    }
}
exports.prepareCursorQuery = prepareCursorQuery;
//# sourceMappingURL=connection.js.map