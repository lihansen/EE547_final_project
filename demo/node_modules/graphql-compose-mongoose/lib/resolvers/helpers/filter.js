"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterHelper = exports.filterHelperArgs = exports.getFilterHelperArgOptsMap = void 0;
const graphql_compose_1 = require("graphql-compose");
const utils_1 = require("../../utils");
const filterOperators_1 = require("./filterOperators");
const makeFieldsRecursiveNullable_1 = require("../../utils/makeFieldsRecursiveNullable");
const getFilterHelperArgOptsMap = () => ({
    isRequired: 'boolean',
    onlyIndexed: 'boolean',
    requiredFields: ['string', 'string[]'],
    operators: ['FilterOperatorsOptsMap', 'boolean'],
    removeFields: ['string', 'string[]'],
});
exports.getFilterHelperArgOptsMap = getFilterHelperArgOptsMap;
function filterHelperArgs(typeComposer, model, opts) {
    if (!(typeComposer instanceof graphql_compose_1.ObjectTypeComposer)) {
        throw new Error('First arg for filterHelperArgs() should be instance of ObjectTypeComposer.');
    }
    if (!model || !model.modelName || !model.schema) {
        throw new Error('Second arg for filterHelperArgs() should be instance of MongooseModel.');
    }
    if (!opts) {
        throw new Error('You should provide non-empty options.');
    }
    const removeFields = [];
    if (opts.removeFields) {
        if (Array.isArray(opts.removeFields)) {
            removeFields.push(...opts.removeFields);
        }
        else {
            removeFields.push(opts.removeFields);
        }
    }
    if (opts.onlyIndexed) {
        const indexedFieldNames = (0, utils_1.getIndexedFieldNamesForGraphQL)(model);
        Object.keys(typeComposer.getFields()).forEach((fieldName) => {
            if (indexedFieldNames.indexOf(fieldName) === -1) {
                removeFields.push(fieldName);
            }
        });
    }
    const { prefix, suffix } = opts;
    const filterTypeName = `${prefix}${typeComposer.getTypeName()}${suffix}`;
    let itc;
    if (typeComposer.schemaComposer.hasInstance(filterTypeName, graphql_compose_1.InputTypeComposer)) {
        itc = typeComposer.schemaComposer.getITC(filterTypeName);
    }
    else {
        itc = typeComposer.getInputTypeComposer().clone(filterTypeName);
        (0, makeFieldsRecursiveNullable_1.makeFieldsRecursiveNullable)(itc, { prefix, suffix });
        itc.removeField(removeFields);
        if (opts.requiredFields) {
            itc.makeFieldNonNull(opts.requiredFields);
        }
        if (itc.getFieldNames().length === 0) {
            return {};
        }
        if (!opts.baseTypeName) {
            opts.baseTypeName = typeComposer.getTypeName();
        }
        (0, filterOperators_1.addFilterOperators)(itc, model, opts);
    }
    return {
        filter: {
            type: opts.isRequired ? itc.NonNull : itc,
            description: opts.onlyIndexed ? 'Filter only by indexed fields' : 'Filter by fields',
        },
    };
}
exports.filterHelperArgs = filterHelperArgs;
function filterHelper(resolveParams, aliases) {
    var _a, _b, _c;
    const filter = (_a = resolveParams.args) === null || _a === void 0 ? void 0 : _a.filter;
    if (filter && typeof filter === 'object' && Object.keys(filter).length > 0) {
        const schemaFields = (_c = (_b = resolveParams.query) === null || _b === void 0 ? void 0 : _b.schema) === null || _c === void 0 ? void 0 : _c.paths;
        const { _ids } = filter, filterFields = __rest(filter, ["_ids"]);
        if (_ids && Array.isArray(_ids)) {
            resolveParams.query = resolveParams.query.where({ _id: { $in: _ids } });
        }
        (0, filterOperators_1.processFilterOperators)(filterFields);
        const mongooseFilter = convertFilterFields(filterFields, schemaFields, aliases);
        if (Object.keys(mongooseFilter).length > 0) {
            resolveParams.query = resolveParams.query.where(mongooseFilter);
        }
    }
    if ((0, utils_1.isObject)(resolveParams.rawQuery)) {
        resolveParams.query = resolveParams.query.where(resolveParams.rawQuery);
    }
}
exports.filterHelper = filterHelper;
function convertFilterFields(filterFields, schemaFields, aliases) {
    const clearedFilter = {};
    Object.keys(filterFields).forEach((key) => {
        const value = filterFields[key];
        if (key.startsWith('$')) {
            clearedFilter[key] = Array.isArray(value)
                ? value.map((v) => (0, utils_1.toMongoFilterDottedObject)(v, aliases))
                : (0, utils_1.toMongoFilterDottedObject)(value, aliases);
        }
        else if (schemaFields[key] ||
            (aliases === null || aliases === void 0 ? void 0 : aliases[key]) ||
            isNestedFilterField(key, value, schemaFields)) {
            const alias = aliases === null || aliases === void 0 ? void 0 : aliases[key];
            let newKey;
            let subAlias;
            if (typeof alias === 'string') {
                newKey = alias;
            }
            else if ((0, utils_1.isObject)(alias)) {
                subAlias = alias;
                newKey = alias === null || alias === void 0 ? void 0 : alias.__selfAlias;
            }
            else {
                newKey = key;
            }
            (0, utils_1.toMongoFilterDottedObject)(value, subAlias, clearedFilter, newKey);
        }
    });
    return clearedFilter;
}
function isNestedFilterField(key, value, schemaFields) {
    if (!(0, utils_1.isObject)(value))
        return false;
    return Object.keys(schemaFields).some((dottedPath) => dottedPath.startsWith(`${key}.`));
}
//# sourceMappingURL=filter.js.map