"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareNestedAliases = exports.replaceAliases = exports.prepareAliasesReverse = exports.prepareAliases = void 0;
const graphql_compose_1 = require("graphql-compose");
function prepareAliases(model) {
    var _a;
    const aliases = ((_a = model === null || model === void 0 ? void 0 : model.schema) === null || _a === void 0 ? void 0 : _a.aliases) || {};
    if (model.discriminators) {
        Object.keys(model.discriminators).forEach((subModelName) => {
            var _a;
            const subModel = model.discriminators[subModelName];
            Object.assign(aliases, (_a = subModel === null || subModel === void 0 ? void 0 : subModel.schema) === null || _a === void 0 ? void 0 : _a.aliases);
        });
    }
    if (Object.keys(aliases).length > 0) {
        return aliases;
    }
    return false;
}
exports.prepareAliases = prepareAliases;
function prepareAliasesReverse(schema) {
    var _a;
    const aliases = (_a = schema) === null || _a === void 0 ? void 0 : _a.aliases;
    const keys = Object.keys(aliases);
    if (keys.length > 0) {
        const r = {};
        keys.forEach((k) => {
            r[aliases[k]] = k;
        });
        return r;
    }
    return false;
}
exports.prepareAliasesReverse = prepareAliasesReverse;
function replaceAliases(data, aliases) {
    if (aliases) {
        const res = Object.assign({}, data);
        Object.keys(data).forEach((key) => {
            if (aliases === null || aliases === void 0 ? void 0 : aliases[key]) {
                const alias = aliases === null || aliases === void 0 ? void 0 : aliases[key];
                let aliasValue;
                if (typeof alias === 'string') {
                    aliasValue = alias;
                }
                else if ((0, graphql_compose_1.isObject)(alias)) {
                    aliasValue = alias === null || alias === void 0 ? void 0 : alias.__selfAlias;
                }
                res[aliasValue || key] = (0, graphql_compose_1.isObject)(res[key])
                    ? replaceAliases(res[key], (0, graphql_compose_1.isObject)(alias) ? alias : undefined)
                    : res[key];
                if (aliasValue) {
                    delete res[key];
                }
            }
        });
        return res;
    }
    return data;
}
exports.replaceAliases = replaceAliases;
function prepareNestedAliases(schema, preparedAliases = new Map()) {
    if (preparedAliases.has(schema)) {
        return preparedAliases.get(schema);
    }
    const aliases = {};
    preparedAliases.set(schema, aliases);
    const discriminators = schema.discriminators;
    if (discriminators) {
        Object.keys(discriminators).forEach((discSchemaName) => {
            const discSchema = discriminators[discSchemaName];
            const additionalAliases = prepareNestedAliases(discSchema, preparedAliases);
            Object.assign(aliases, additionalAliases);
        });
    }
    Object.keys(schema.paths).forEach((path) => {
        var _a, _b, _c, _d, _e, _f;
        const field = schema.paths[path];
        let fieldName = path;
        if ((_b = (_a = field) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.alias) {
            fieldName = (_d = (_c = field) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.alias;
            aliases[fieldName] = path;
        }
        if ((_e = field) === null || _e === void 0 ? void 0 : _e.schema) {
            const nestedSchema = (_f = field) === null || _f === void 0 ? void 0 : _f.schema;
            const nestedAliases = prepareNestedAliases(nestedSchema, preparedAliases);
            if (nestedAliases) {
                const topKey = aliases[fieldName];
                if (topKey && typeof topKey === 'string') {
                    aliases[fieldName] = {
                        __selfAlias: topKey,
                    };
                }
                aliases[fieldName] = Object.assign(aliases[fieldName] || {}, nestedAliases);
            }
        }
    });
    if (!Object.keys(aliases).length) {
        preparedAliases.set(schema, undefined);
        return undefined;
    }
    return aliases;
}
exports.prepareNestedAliases = prepareNestedAliases;
//# sourceMappingURL=aliases.js.map