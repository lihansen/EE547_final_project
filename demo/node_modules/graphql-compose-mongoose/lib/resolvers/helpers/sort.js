"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSortTypeFromModel = exports.sortHelper = exports.sortHelperArgs = void 0;
const graphql_compose_1 = require("graphql-compose");
const getIndexesFromModel_1 = require("../../utils/getIndexesFromModel");
function sortHelperArgs(tc, model, opts) {
    if (!tc || tc.constructor.name !== 'ObjectTypeComposer') {
        throw new Error('First arg for sortHelperArgs() should be instance of ObjectTypeComposer.');
    }
    if (!model || !model.modelName || !model.schema) {
        throw new Error('Second arg for sortHelperArgs() should be instance of Mongoose Model.');
    }
    if (!opts || !opts.sortTypeName) {
        throw new Error('You should provide non-empty `sortTypeName` in options for sortHelperArgs().');
    }
    const gqSortType = getSortTypeFromModel(opts.sortTypeName, model, tc.schemaComposer);
    return {
        sort: {
            type: (opts === null || opts === void 0 ? void 0 : opts.multi) ? gqSortType.NonNull.List : gqSortType,
        },
    };
}
exports.sortHelperArgs = sortHelperArgs;
function sortHelper(resolveParams) {
    var _a;
    const _sort = (_a = resolveParams === null || resolveParams === void 0 ? void 0 : resolveParams.args) === null || _a === void 0 ? void 0 : _a.sort;
    if (!_sort)
        return;
    let sort;
    if (Array.isArray(_sort)) {
        sort = {};
        _sort.forEach((o) => {
            if ((0, graphql_compose_1.isObject)(o)) {
                Object.keys(o).forEach((key) => {
                    if (!sort.hasOwnProperty(key)) {
                        sort[key] = o[key];
                    }
                });
            }
        });
    }
    else {
        sort = _sort;
    }
    if (typeof sort === 'object' && Object.keys(sort).length > 0) {
        resolveParams.query = resolveParams.query.sort(sort);
    }
}
exports.sortHelper = sortHelper;
function getSortTypeFromModel(typeName, model, schemaComposer) {
    return schemaComposer.getOrCreateETC(typeName, (etc) => {
        const indexes = (0, getIndexesFromModel_1.extendByReversedIndexes)((0, getIndexesFromModel_1.getIndexesFromModel)(model));
        const fields = {};
        indexes.forEach((indexData) => {
            const keys = Object.keys(indexData);
            let name = keys
                .join('__')
                .toUpperCase()
                .replace(/[^_a-zA-Z0-9]/gi, '__');
            if (indexData[keys[0]] === 1) {
                name = `${name}_ASC`;
            }
            else if (indexData[keys[0]] === -1) {
                name = `${name}_DESC`;
            }
            fields[name] = {
                value: indexData,
            };
        });
        etc.setFields(fields);
    });
}
exports.getSortTypeFromModel = getSortTypeFromModel;
//# sourceMappingURL=sort.js.map