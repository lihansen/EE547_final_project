"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createResolvers = exports.composeWithMongoose = void 0;
const graphql_compose_1 = require("graphql-compose");
const fieldsConverter_1 = require("./fieldsConverter");
const resolvers_1 = require("./resolvers");
const MongoID_1 = __importDefault(require("./types/MongoID"));
const composeMongoose_1 = require("./composeMongoose");
function composeWithMongoose(model, opts = {}) {
    const m = model;
    const name = (opts && opts.name) || m.modelName;
    const sc = opts.schemaComposer || graphql_compose_1.schemaComposer;
    sc.add(MongoID_1.default);
    if (sc.has(name)) {
        throw new Error(`You try to generate GraphQL Type with name ${name} from mongoose model but this type already exists in SchemaComposer. Please choose another type name "composeWithMongoose(model, { name: 'NewTypeName' })", or reuse existed type "schemaComposer.getOTC('TypeName')", or remove type from SchemaComposer before calling composeWithMongoose method "schemaComposer.delete('TypeName')".`);
    }
    if (sc.has(m.schema)) {
        sc.delete(m.schema);
    }
    const tc = (0, fieldsConverter_1.convertModelToGraphQL)(m, name, sc);
    if (opts.description) {
        tc.setDescription(opts.description);
    }
    (0, composeMongoose_1.prepareFields)(tc, opts);
    (0, composeMongoose_1.createInputType)(tc, opts.inputType);
    if (!{}.hasOwnProperty.call(opts, 'resolvers') || opts.resolvers !== false) {
        createResolvers(m, tc, opts.resolvers || {});
    }
    tc.makeFieldNonNull('_id');
    return tc;
}
exports.composeWithMongoose = composeWithMongoose;
function createResolvers(model, tc, opts) {
    Object.keys(resolvers_1.resolverFactory).forEach((resolverName) => {
        if (!opts.hasOwnProperty(resolverName) || opts[resolverName] !== false) {
            const createResolverFn = resolvers_1.resolverFactory[resolverName];
            if (typeof createResolverFn === 'function') {
                const resolver = createResolverFn(model, tc, opts[resolverName] || {});
                if (resolver) {
                    tc.setResolver(resolverName, resolver);
                }
            }
        }
    });
}
exports.createResolvers = createResolvers;
//# sourceMappingURL=composeWithMongoose.js.map