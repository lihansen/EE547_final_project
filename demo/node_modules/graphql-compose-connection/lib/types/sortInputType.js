"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkSortOpts = exports.prepareSortType = void 0;
const graphql_compose_1 = require("graphql-compose");
function prepareSortType(typeComposer, opts) {
    if (!opts || !opts.sort) {
        throw new Error('Option `sort` should not be empty in composeWithConnection');
    }
    const typeName = `Sort${graphql_compose_1.upperFirst(opts.name || 'connection')}${typeComposer.getTypeName()}Enum`;
    const sortKeys = Object.keys(opts.sort);
    if (sortKeys.length === 0) {
        throw new Error('You should provide at least one `sort` option ' +
            `for composeWithConnection(${typeComposer.getTypeName()}, opts) in opts.sort`);
    }
    const sortEnumValues = {};
    sortKeys.forEach((sortKey) => {
        checkSortOpts(sortKey, opts.sort[sortKey]);
        sortEnumValues[sortKey] = {
            name: sortKey,
            value: opts.sort[sortKey].value,
        };
    });
    const sortType = typeComposer.schemaComposer.createEnumTC({
        name: typeName,
        values: sortEnumValues,
    });
    return sortType;
}
exports.prepareSortType = prepareSortType;
function checkSortOpts(key, opts) {
    if (!opts.value) {
        throw new Error('You should provide `value` ' +
            `for composeWithConnection in opts.sort.${key}. ` +
            'Connections does not work without sorting.');
    }
    if (!opts.cursorFields || !Array.isArray(opts.cursorFields)) {
        throw new Error('You should provide array of field(s) in `cursorFields` ' +
            `for composeWithConnection in opts.sort.${key}` +
            'Ideally this field(s) should be in unique index. ' +
            'Connection will work incorrectly, if some records have same values.');
    }
    if (!opts.beforeCursorQuery || !graphql_compose_1.isFunction(opts.beforeCursorQuery)) {
        throw new Error('You should provide `beforeCursorQuery` function ' +
            `for composeWithConnection in opts.sort.${key}. ` +
            'Connections should have ability to filter ' +
            'backward records started from cursor.');
    }
    if (!opts.afterCursorQuery || !graphql_compose_1.isFunction(opts.afterCursorQuery)) {
        throw new Error('You should provide `afterCursorQuery` function ' +
            `for composeWithConnection in opts.sort.${key}. ` +
            'Connections should have ability to filter ' +
            'forward records started from cursor.');
    }
}
exports.checkSortOpts = checkSortOpts;
//# sourceMappingURL=sortInputType.js.map